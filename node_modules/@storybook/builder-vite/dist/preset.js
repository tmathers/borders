import CJS_COMPAT_NODE_URL_23js8tm0sz2 from 'node:url';
import CJS_COMPAT_NODE_PATH_23js8tm0sz2 from 'node:path';
import CJS_COMPAT_NODE_MODULE_23js8tm0sz2 from "node:module";

var __filename = CJS_COMPAT_NODE_URL_23js8tm0sz2.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_23js8tm0sz2.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_23js8tm0sz2.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  normalize
} from "./_node-chunks/chunk-AAQP5ISI.js";

// src/preset.ts
import { findConfigFile } from "storybook/internal/common";

// src/plugins/vite-inject-mocker/plugin.ts
import { fileURLToPath } from "node:url";
var ENTRY_PATH = "/vite-inject-mocker-entry.js", viteInjectMockerRuntime = (options) => {
  let mockerRuntimePath = fileURLToPath(
    import.meta.resolve("storybook/internal/mocking-utils/mocker-runtime")
  ), viteConfig;
  return {
    name: "vite:storybook-inject-mocker-runtime",
    enforce: "pre",
    buildStart() {
      viteConfig.command === "build" && this.emitFile({
        type: "chunk",
        id: mockerRuntimePath,
        fileName: ENTRY_PATH.slice(1)
      });
    },
    configResolved(config) {
      viteConfig = config;
    },
    configureServer(server) {
      options.previewConfigPath && server.watcher.on("change", (file) => {
        file === options.previewConfigPath && server.ws.send({
          type: "custom",
          event: "invalidate-mocker"
        });
      });
    },
    resolveId(source) {
      if (source === ENTRY_PATH)
        return mockerRuntimePath;
    },
    transformIndexHtml(html) {
      let headTag = html.match(/<head[^>]*>/);
      if (headTag) {
        let entryCode = `<script type="module" src="${ENTRY_PATH}"></script>`, headTagIndex = html.indexOf(headTag[0]);
        return html.slice(0, headTagIndex + headTag[0].length) + entryCode + html.slice(headTagIndex + headTag[0].length);
      }
    }
  };
};

// src/plugins/vite-mock/plugin.ts
import { readFileSync } from "node:fs";
import {
  babelParser,
  extractMockCalls,
  findMockRedirect,
  getAutomockCode,
  getRealPath,
  rewriteSbMockImportCalls
} from "storybook/internal/mocking-utils";
import { logger } from "storybook/internal/node-logger";

// src/plugins/vite-mock/utils.ts
function getCleanId(id) {
  return id.replace(/^.*\/deps\//, "").replace(/\.js.*$/, "").replace(/_/g, "/");
}
function invalidateAllRelatedModules(server, absPath, pkgName) {
  for (let mod of server.moduleGraph.idToModuleMap.values())
    (mod.id === absPath || mod.id && getCleanId(mod.id) === pkgName) && server.moduleGraph.invalidateModule(mod);
}

// src/plugins/vite-mock/plugin.ts
function viteMockPlugin(options) {
  let viteConfig, mockCalls = [], normalizedPreviewConfigPath = normalize(options.previewConfigPath);
  return [
    {
      name: "storybook:mock-loader",
      configResolved(config) {
        viteConfig = config;
      },
      buildStart() {
        mockCalls = extractMockCalls(options, babelParser, viteConfig.root, findMockRedirect);
      },
      configureServer(server) {
        async function invalidateAffectedFiles(file) {
          if (file === options.previewConfigPath || file.includes("__mocks__")) {
            let oldMockCalls = mockCalls;
            mockCalls = extractMockCalls(options, babelParser, viteConfig.root, findMockRedirect);
            let previewMod = server.moduleGraph.getModuleById(options.previewConfigPath);
            previewMod && server.moduleGraph.invalidateModule(previewMod);
            for (let call of mockCalls)
              invalidateAllRelatedModules(server, call.absolutePath, call.path);
            let newAbsPaths = new Set(mockCalls.map((c) => c.absolutePath));
            for (let oldCall of oldMockCalls)
              newAbsPaths.has(oldCall.absolutePath) || invalidateAllRelatedModules(server, oldCall.absolutePath, oldCall.path);
            return server.ws.send({ type: "full-reload" }), [];
          }
        }
        server.watcher.on("change", invalidateAffectedFiles), server.watcher.on("add", invalidateAffectedFiles), server.watcher.on("unlink", invalidateAffectedFiles);
      },
      load: {
        order: "pre",
        handler(id) {
          let preserveSymlinks = viteConfig.resolve.preserveSymlinks, idNorm = getRealPath(id, preserveSymlinks), cleanId = getCleanId(idNorm);
          for (let call of mockCalls)
            if (!(getRealPath(call.absolutePath, preserveSymlinks) !== idNorm && call.path !== cleanId) && call.redirectPath)
              return this.addWatchFile(call.redirectPath), readFileSync(call.redirectPath, "utf-8");
          return null;
        }
      },
      transform: {
        order: "pre",
        handler(code, id) {
          for (let call of mockCalls) {
            let preserveSymlinks = viteConfig.resolve.preserveSymlinks, idNorm = getRealPath(id, preserveSymlinks), callNorm = getRealPath(call.absolutePath, preserveSymlinks);
            if (viteConfig.command !== "serve") {
              if (callNorm !== idNorm)
                continue;
            } else {
              let cleanId = getCleanId(idNorm);
              if (call.path !== cleanId && callNorm !== idNorm)
                continue;
            }
            try {
              if (!call.redirectPath) {
                let automockedCode = getAutomockCode(code, call.spy, babelParser);
                return {
                  code: automockedCode.toString(),
                  map: automockedCode.generateMap()
                };
              }
            } catch (e) {
              return logger.error(`Error automocking ${id}: ${e}`), null;
            }
          }
          return null;
        }
      }
    },
    {
      name: "storybook:mock-loader-preview",
      transform(code, id) {
        if (id === normalizedPreviewConfigPath)
          try {
            return rewriteSbMockImportCalls(code);
          } catch (e) {
            return logger.debug(`Could not transform sb.mock(import(...)) calls in ${id}: ${e}`), null;
          }
        return null;
      }
    }
  ];
}

// src/preset.ts
async function viteFinal(existing, options) {
  let previewConfigPath = findConfigFile("preview", options.configDir);
  if (!previewConfigPath)
    return existing;
  let coreOptions = await options.presets.apply("core");
  return {
    ...existing,
    plugins: [
      ...existing.plugins ?? [],
      ...previewConfigPath ? [
        viteInjectMockerRuntime({ previewConfigPath }),
        viteMockPlugin({ previewConfigPath, coreOptions, configDir: options.configDir })
      ] : []
    ]
  };
}
export {
  viteFinal
};
