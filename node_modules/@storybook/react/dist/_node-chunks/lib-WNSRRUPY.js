import CJS_COMPAT_NODE_URL_edn3aaa4vmn from 'node:url';
import CJS_COMPAT_NODE_PATH_edn3aaa4vmn from 'node:path';
import CJS_COMPAT_NODE_MODULE_edn3aaa4vmn from "node:module";

var __filename = CJS_COMPAT_NODE_URL_edn3aaa4vmn.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_edn3aaa4vmn.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_edn3aaa4vmn.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  __commonJS,
  __require
} from "./chunk-X74AE4J3.js";

// ../../../node_modules/react-docgen-typescript/lib/buildFilter.js
var require_buildFilter = __commonJS({
  "../../../node_modules/react-docgen-typescript/lib/buildFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.buildFilter = void 0;
    function buildFilter(opts) {
      return function(prop, component) {
        var propFilter = opts.propFilter;
        if (prop.name === "children" && prop.description.length === 0 && opts.skipChildrenPropWithoutDoc !== !1)
          return !1;
        if (typeof propFilter == "function") {
          var keep = propFilter(prop, component);
          if (!keep)
            return !1;
        } else if (typeof propFilter == "object") {
          var _a = propFilter, skipPropsWithName = _a.skipPropsWithName, skipPropsWithoutDoc = _a.skipPropsWithoutDoc;
          if (typeof skipPropsWithName == "string" && skipPropsWithName === prop.name)
            return !1;
          if (Array.isArray(skipPropsWithName) && skipPropsWithName.indexOf(prop.name) > -1 || skipPropsWithoutDoc && prop.description.length === 0)
            return !1;
        }
        return !0;
      };
    }
    exports.buildFilter = buildFilter;
  }
});

// ../../../node_modules/react-docgen-typescript/lib/trimFileName.js
var require_trimFileName = __commonJS({
  "../../../node_modules/react-docgen-typescript/lib/trimFileName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.trimFileName = void 0;
    var path = __require("path"), slashRegex = /[\\/]/g, fileNameCache = /* @__PURE__ */ new Map();
    function trimFileName(fileName, cwd, platform) {
      var _a;
      if (cwd === void 0 && (cwd = process.cwd()), fileNameCache.has(fileName))
        return fileNameCache.get(fileName);
      var pathLib = platform ? path[platform] : path, originalSep = ((_a = fileName.match(slashRegex)) === null || _a === void 0 ? void 0 : _a[0]) || pathLib.sep, normalizedFileName = pathLib.normalize(fileName), root = pathLib.parse(cwd).root, parent = cwd;
      do {
        if (normalizedFileName.startsWith(parent)) {
          var finalPathName = pathLib.relative(pathLib.dirname(parent), normalizedFileName).replace(slashRegex, originalSep);
          return fileNameCache.set(fileName, finalPathName), finalPathName;
        }
        parent = pathLib.dirname(parent);
      } while (parent !== root);
      return fileNameCache.set(fileName, fileName), fileName;
    }
    exports.trimFileName = trimFileName;
  }
});

// ../../../node_modules/react-docgen-typescript/lib/parser.js
var require_parser = __commonJS({
  "../../../node_modules/react-docgen-typescript/lib/parser.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      return __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, __assign.apply(this, arguments);
    }, __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getDefaultExportForFile = exports.Parser = exports.withCompilerOptions = exports.withCustomConfig = exports.withDefaultConfig = exports.parse = exports.defaultOptions = exports.defaultParserOpts = void 0;
    var fs = __require("fs"), path = __require("path"), ts = __require("typescript"), buildFilter_1 = require_buildFilter(), trimFileName_1 = require_trimFileName();
    exports.defaultParserOpts = {};
    exports.defaultOptions = {
      jsx: ts.JsxEmit.React,
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.Latest,
      esModuleInterop: !0
    };
    function parse(filePathOrPaths, parserOpts) {
      return parserOpts === void 0 && (parserOpts = exports.defaultParserOpts), withCompilerOptions(exports.defaultOptions, parserOpts).parse(filePathOrPaths);
    }
    exports.parse = parse;
    function withDefaultConfig(parserOpts) {
      return parserOpts === void 0 && (parserOpts = exports.defaultParserOpts), withCompilerOptions(exports.defaultOptions, parserOpts);
    }
    exports.withDefaultConfig = withDefaultConfig;
    function withCustomConfig(tsconfigPath, parserOpts) {
      var basePath = path.dirname(tsconfigPath), _a = ts.readConfigFile(tsconfigPath, function(filename) {
        return fs.readFileSync(filename, "utf8");
      }), config = _a.config, error = _a.error;
      if (error !== void 0) {
        var errorText = "Cannot load custom tsconfig.json from provided path: " + tsconfigPath + ", with error code: " + error.code + ", message: " + error.messageText;
        throw new Error(errorText);
      }
      var _b = ts.parseJsonConfigFileContent(config, ts.sys, basePath, {}, tsconfigPath), options = _b.options, errors = _b.errors;
      if (errors && errors.length)
        throw errors[0] instanceof Error ? errors[0] : errors[0].messageText ? new Error("TS" + errors[0].code + ": " + errors[0].messageText) : new Error(JSON.stringify(errors[0]));
      return withCompilerOptions(options, parserOpts);
    }
    exports.withCustomConfig = withCustomConfig;
    function withCompilerOptions(compilerOptions, parserOpts) {
      return parserOpts === void 0 && (parserOpts = exports.defaultParserOpts), {
        parse: function(filePathOrPaths) {
          return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts);
        },
        parseWithProgramProvider: function(filePathOrPaths, programProvider) {
          return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider);
        }
      };
    }
    exports.withCompilerOptions = withCompilerOptions;
    var isOptional = function(prop) {
      return (prop.getFlags() & ts.SymbolFlags.Optional) !== 0;
    }, defaultJSDoc = {
      description: "",
      fullComment: "",
      tags: {}
    }, Parser = (
      /** @class */
      (function() {
        function Parser2(program, opts) {
          this.propertiesOfPropsCache = /* @__PURE__ */ new Map(), this.componentsInfoCache = /* @__PURE__ */ new Map();
          var savePropValueAsString = opts.savePropValueAsString, shouldExtractLiteralValuesFromEnum = opts.shouldExtractLiteralValuesFromEnum, shouldRemoveUndefinedFromOptional = opts.shouldRemoveUndefinedFromOptional, shouldExtractValuesFromUnion = opts.shouldExtractValuesFromUnion, shouldSortUnions = opts.shouldSortUnions, shouldIncludePropTagMap = opts.shouldIncludePropTagMap, shouldIncludeExpression = opts.shouldIncludeExpression;
          this.checker = program.getTypeChecker(), this.propFilter = buildFilter_1.buildFilter(opts), this.shouldExtractLiteralValuesFromEnum = !!shouldExtractLiteralValuesFromEnum, this.shouldRemoveUndefinedFromOptional = !!shouldRemoveUndefinedFromOptional, this.shouldExtractValuesFromUnion = !!shouldExtractValuesFromUnion, this.shouldSortUnions = !!shouldSortUnions, this.savePropValueAsString = !!savePropValueAsString, this.shouldIncludePropTagMap = !!shouldIncludePropTagMap, this.shouldIncludeExpression = !!shouldIncludeExpression;
        }
        return Parser2.prototype.getTypeSymbol = function(exp) {
          var declaration = exp.valueDeclaration || exp.declarations[0], type = this.checker.getTypeOfSymbolAtLocation(exp, declaration), typeSymbol = type.symbol || type.aliasSymbol;
          return typeSymbol;
        }, Parser2.prototype.isPlainObjectType = function(exp) {
          var targetSymbol = exp;
          exp.flags & ts.SymbolFlags.Alias && (targetSymbol = this.checker.getAliasedSymbol(exp));
          var declaration = targetSymbol.valueDeclaration;
          if (!declaration || ts.isClassDeclaration(declaration))
            return !1;
          var type = this.checker.getTypeOfSymbolAtLocation(targetSymbol, declaration);
          if (!(type.flags & ts.TypeFlags.Object))
            return !1;
          var objectType = type, isPlain = !!(objectType.objectFlags & (ts.ObjectFlags.Anonymous | ts.ObjectFlags.ObjectLiteral));
          return isPlain;
        }, Parser2.prototype.getComponentExports = function(exp) {
          var targetSymbol = exp;
          if (targetSymbol.exports)
            return { symbol: targetSymbol, exports: targetSymbol.exports };
          if (exp.flags & ts.SymbolFlags.Alias && (targetSymbol = this.checker.getAliasedSymbol(exp)), targetSymbol.exports)
            return { symbol: targetSymbol, exports: targetSymbol.exports };
        }, Parser2.prototype.getComponentFromExpression = function(exp) {
          var declaration = exp.valueDeclaration || exp.declarations[0];
          if (declaration && ts.isPropertyAssignment(declaration) && ts.isIdentifier(declaration.initializer)) {
            var newSymbol = this.checker.getSymbolAtLocation(declaration.initializer);
            newSymbol && (exp = newSymbol, declaration = exp.valueDeclaration || exp.declarations[0]);
          }
          var type = this.checker.getTypeOfSymbolAtLocation(exp, declaration), typeSymbol = type.symbol || type.aliasSymbol;
          if (!typeSymbol)
            return exp;
          var symbolName = typeSymbol.getName();
          if ((symbolName === "MemoExoticComponent" || symbolName === "ForwardRefExoticComponent") && exp.valueDeclaration && ts.isExportAssignment(exp.valueDeclaration) && ts.isCallExpression(exp.valueDeclaration.expression)) {
            var component = this.checker.getSymbolAtLocation(exp.valueDeclaration.expression.arguments[0]);
            component && (exp = component);
          }
          return exp;
        }, Parser2.prototype.getComponentInfo = function(exp, source, componentNameResolver, customComponentTypes) {
          if (componentNameResolver === void 0 && (componentNameResolver = function() {
          }), customComponentTypes === void 0 && (customComponentTypes = []), exp.declarations && exp.declarations.length === 0)
            return null;
          var rootExp = this.getComponentFromExpression(exp), declaration = rootExp.valueDeclaration || rootExp.declarations[0], type = this.checker.getTypeOfSymbolAtLocation(rootExp, declaration), commentSource = rootExp, typeSymbol = type.symbol || type.aliasSymbol, originalName = rootExp.getName(), filePath = source.fileName, cacheKey = filePath + "_" + originalName;
          if (this.componentsInfoCache.has(cacheKey))
            return this.componentsInfoCache.get(cacheKey);
          if (rootExp.valueDeclaration)
            type.symbol && (ts.isPropertyAccessExpression(declaration) || ts.isPropertyDeclaration(declaration)) && (commentSource = type.symbol);
          else if (!typeSymbol && (rootExp.flags & ts.SymbolFlags.Alias) !== 0)
            commentSource = this.checker.getAliasedSymbol(commentSource);
          else if (typeSymbol) {
            rootExp = typeSymbol;
            var expName = rootExp.getName(), defaultComponentTypes = [
              "__function",
              "StatelessComponent",
              "Stateless",
              "StyledComponentClass",
              "StyledComponent",
              "IStyledComponent",
              "FunctionComponent",
              "ForwardRefExoticComponent",
              "MemoExoticComponent"
            ], supportedComponentTypes = __spreadArray(__spreadArray([], defaultComponentTypes), customComponentTypes);
            supportedComponentTypes.indexOf(expName) !== -1 ? commentSource = this.checker.getAliasedSymbol(commentSource) : commentSource = rootExp;
          } else
            return this.componentsInfoCache.set(cacheKey, null), null;
          if (typeSymbol && (typeSymbol.getEscapedName() === "Requireable" || typeSymbol.getEscapedName() === "Validator"))
            return this.componentsInfoCache.set(cacheKey, null), null;
          var propsType = this.extractPropsFromTypeIfStatelessComponent(type) || this.extractPropsFromTypeIfStatefulComponent(type), nameSource = originalName === "default" ? rootExp : commentSource, resolvedComponentName = componentNameResolver(nameSource, source), _a = this.findDocComment(commentSource), description = _a.description, tags = _a.tags, displayName = resolvedComponentName || tags.visibleName || computeComponentName(nameSource, source, customComponentTypes), methods = this.getMethodsInfo(type), result = null;
          if (propsType) {
            if (!commentSource.valueDeclaration)
              return this.componentsInfoCache.set(cacheKey, null), null;
            for (var defaultProps = this.extractDefaultPropsFromComponent(commentSource, commentSource.valueDeclaration.getSourceFile()), props = this.getPropsInfo(propsType, defaultProps), _i = 0, _b = Object.keys(props); _i < _b.length; _i++) {
              var propName = _b[_i], prop = props[propName], component = { name: displayName };
              this.propFilter(prop, component) || delete props[propName];
            }
            result = {
              tags,
              filePath,
              description,
              displayName,
              methods,
              props
            };
          } else description && displayName && (result = {
            tags,
            filePath,
            description,
            displayName,
            methods,
            props: {}
          });
          return result !== null && this.shouldIncludeExpression && (result.expression = rootExp, result.rootExpression = exp), this.componentsInfoCache.set(cacheKey, result), result;
        }, Parser2.prototype.extractPropsFromTypeIfStatelessComponent = function(type) {
          var callSignatures = type.getCallSignatures();
          if (callSignatures.length)
            for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {
              var sig = callSignatures_1[_i], params = sig.getParameters();
              if (params.length !== 0) {
                var propsParam = params[0];
                if (propsParam.name === "props" || params.length === 1)
                  return propsParam;
              }
            }
          return null;
        }, Parser2.prototype.extractPropsFromTypeIfStatefulComponent = function(type) {
          var constructSignatures = type.getConstructSignatures();
          if (constructSignatures.length)
            for (var _i = 0, constructSignatures_1 = constructSignatures; _i < constructSignatures_1.length; _i++) {
              var sig = constructSignatures_1[_i], instanceType = sig.getReturnType(), props = instanceType.getProperty("props");
              if (props)
                return props;
            }
          return null;
        }, Parser2.prototype.extractMembersFromType = function(type) {
          var _this = this, methodSymbols = [];
          return type.getProperties().forEach(function(property) {
            _this.getCallSignature(property) && methodSymbols.push(property);
          }), type.symbol && type.symbol.members && type.symbol.members.forEach(function(member) {
            methodSymbols.push(member);
          }), methodSymbols;
        }, Parser2.prototype.getMethodsInfo = function(type) {
          var _this = this, members = this.extractMembersFromType(type), methods = [];
          return members.forEach(function(member) {
            if (_this.isTaggedPublic(member)) {
              var name = member.getName(), docblock = _this.getFullJsDocComment(member).fullComment, callSignature = _this.getCallSignature(member), params = _this.getParameterInfo(callSignature), description = ts.displayPartsToString(member.getDocumentationComment(_this.checker)), returnType = _this.checker.typeToString(callSignature.getReturnType()), returnDescription = ts.displayPartsToString(_this.getReturnDescription(member)), modifiers = _this.getModifiers(member);
              methods.push({
                description,
                docblock,
                modifiers,
                name,
                params,
                returns: returnDescription ? {
                  description: returnDescription,
                  type: returnType
                } : null
              });
            }
          }), methods;
        }, Parser2.prototype.getModifiers = function(member) {
          var modifiers = [];
          if (!member.valueDeclaration)
            return modifiers;
          var flags = ts.getCombinedModifierFlags(member.valueDeclaration), isStatic = (flags & ts.ModifierFlags.Static) !== 0;
          return isStatic && modifiers.push("static"), modifiers;
        }, Parser2.prototype.getParameterInfo = function(callSignature) {
          var _this = this;
          return callSignature.parameters.map(function(param) {
            var paramType = _this.checker.getTypeOfSymbolAtLocation(param, param.valueDeclaration), paramDeclaration = _this.checker.symbolToParameterDeclaration(param, void 0, void 0), isOptionalParam = !!(paramDeclaration && paramDeclaration.questionToken);
            return {
              description: ts.displayPartsToString(param.getDocumentationComment(_this.checker)) || null,
              name: param.getName() + (isOptionalParam ? "?" : ""),
              type: { name: _this.checker.typeToString(paramType) }
            };
          });
        }, Parser2.prototype.getCallSignature = function(symbol) {
          var symbolType = this.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
          return symbolType.getCallSignatures()[0];
        }, Parser2.prototype.isTaggedPublic = function(symbol) {
          var jsDocTags = symbol.getJsDocTags();
          return !!jsDocTags.find(function(tag) {
            return tag.name === "public";
          });
        }, Parser2.prototype.getReturnDescription = function(symbol) {
          var tags = symbol.getJsDocTags(), returnTag = tags.find(function(tag) {
            return tag.name === "returns";
          });
          if (!(!returnTag || !Array.isArray(returnTag.text)))
            return returnTag.text;
        }, Parser2.prototype.getValuesFromUnionType = function(type) {
          return type.isStringLiteral() ? '"' + type.value + '"' : type.isNumberLiteral() ? "" + type.value : this.checker.typeToString(type);
        }, Parser2.prototype.getInfoFromUnionType = function(type) {
          var commentInfo = {};
          return type.getSymbol() && (commentInfo = __assign({}, this.getFullJsDocComment(type.getSymbol()))), __assign({ value: this.getValuesFromUnionType(type) }, commentInfo);
        }, Parser2.prototype.getDocgenType = function(propType, isRequired) {
          var _this = this;
          propType.getConstraint() && (propType = propType.getConstraint());
          var propTypeString = this.checker.typeToString(propType);
          if (this.shouldRemoveUndefinedFromOptional && !isRequired && (propTypeString = propTypeString.replace(" | undefined", "")), propType.isUnion() && (this.shouldExtractValuesFromUnion || this.shouldExtractLiteralValuesFromEnum && propType.types.every(function(type) {
            return type.getFlags() & (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral | ts.TypeFlags.Undefined);
          }))) {
            var value = propType.types.map(function(type) {
              return _this.getInfoFromUnionType(type);
            });
            return this.shouldRemoveUndefinedFromOptional && !isRequired && (value = value.filter(function(option) {
              return option.value != "undefined";
            })), this.shouldSortUnions && value.sort(function(a, b) {
              return a.value.toString().localeCompare(b.value.toString());
            }), {
              name: "enum",
              raw: propTypeString,
              value
            };
          }
          return this.shouldRemoveUndefinedFromOptional && !isRequired && (propTypeString = propTypeString.replace(" | undefined", "")), { name: propTypeString };
        }, Parser2.prototype.getPropsInfo = function(propsObj, defaultProps) {
          var _this = this;
          if (defaultProps === void 0 && (defaultProps = {}), !propsObj.valueDeclaration)
            return {};
          var propsType = this.checker.getTypeOfSymbolAtLocation(propsObj, propsObj.valueDeclaration), baseProps = propsType.getApparentProperties(), propertiesOfProps = baseProps;
          if (propsType.isUnionOrIntersection() && (propertiesOfProps = __spreadArray(__spreadArray([], propertiesOfProps = this.checker.getAllPossiblePropertiesOfTypes(propsType.types)), baseProps), !propertiesOfProps.length)) {
            var subTypes = this.checker.getAllPossiblePropertiesOfTypes(propsType.types.reduce(
              // @ts-ignore
              function(all, t) {
                return __spreadArray(__spreadArray([], all), t.types || []);
              },
              []
            ));
            propertiesOfProps = __spreadArray(__spreadArray([], subTypes), baseProps);
          }
          var result = {};
          return propertiesOfProps.forEach(function(prop) {
            var propName = prop.getName(), parent = getParentType(prop), cacheKey = parent?.fileName + "_" + propName;
            if (_this.propertiesOfPropsCache.has(cacheKey))
              result[propName] = _this.propertiesOfPropsCache.get(cacheKey);
            else {
              var propType = _this.checker.getTypeOfSymbolAtLocation(prop, propsObj.valueDeclaration), jsDocComment = _this.findDocComment(prop), hasCodeBasedDefault = defaultProps[propName] !== void 0, defaultValue = null;
              hasCodeBasedDefault ? defaultValue = { value: defaultProps[propName] } : jsDocComment.tags.default && (defaultValue = { value: jsDocComment.tags.default });
              var parents = getDeclarations(prop), declarations = prop.declarations || [], baseProp = baseProps.find(function(p) {
                return p.getName() === propName;
              }), required = !isOptional(prop) && !hasCodeBasedDefault && // If in a intersection or union check original declaration for "?"
              // @ts-ignore
              declarations.every(function(d) {
                return !d.questionToken;
              }) && (!baseProp || !isOptional(baseProp)), type = jsDocComment.tags.type ? {
                name: jsDocComment.tags.type
              } : _this.getDocgenType(propType, required), propTags = _this.shouldIncludePropTagMap ? { tags: jsDocComment.tags } : {}, description = _this.shouldIncludePropTagMap ? jsDocComment.description.replace(/\r\n/g, `
`) : jsDocComment.fullComment.replace(/\r\n/g, `
`), propItem = __assign({
                defaultValue,
                description,
                name: propName,
                parent,
                declarations: parents,
                required,
                type
              }, propTags);
              parent?.fileName.includes("node_modules") && _this.propertiesOfPropsCache.set(parent.fileName + "_" + propName, propItem), result[propName] = propItem;
            }
          }), result;
        }, Parser2.prototype.findDocComment = function(symbol) {
          var _this = this, comment = this.getFullJsDocComment(symbol);
          if (comment.fullComment || comment.tags.default)
            return comment;
          var rootSymbols = this.checker.getRootSymbols(symbol), commentsOnRootSymbols = rootSymbols.filter(function(x) {
            return x !== symbol;
          }).map(function(x) {
            return _this.getFullJsDocComment(x);
          }).filter(function(x) {
            return !!x.fullComment || !!comment.tags.default;
          });
          return commentsOnRootSymbols.length ? commentsOnRootSymbols[0] : defaultJSDoc;
        }, Parser2.prototype.getFullJsDocComment = function(symbol) {
          if (symbol.getDocumentationComment === void 0)
            return defaultJSDoc;
          var mainComment = ts.displayPartsToString(symbol.getDocumentationComment(this.checker));
          mainComment && (mainComment = mainComment.replace(/\r\n/g, `
`));
          var tags = symbol.getJsDocTags() || [], tagComments = [], tagMap = {};
          return tags.forEach(function(tag) {
            var trimmedText = ts.displayPartsToString(tag.text).trim(), currentValue = tagMap[tag.name];
            tagMap[tag.name] = currentValue ? currentValue + `
` + trimmedText : trimmedText, ["default", "type"].indexOf(tag.name) < 0 && tagComments.push(formatTag(tag));
          }), {
            description: mainComment,
            fullComment: (mainComment + `
` + tagComments.join(`
`)).trim(),
            tags: tagMap
          };
        }, Parser2.prototype.getFunctionStatement = function(statement) {
          if (ts.isFunctionDeclaration(statement))
            return statement;
          if (ts.isVariableStatement(statement)) {
            var initializer = statement.declarationList && statement.declarationList.declarations[0].initializer;
            if (initializer && ts.isCallExpression(initializer)) {
              var symbol = this.checker.getSymbolAtLocation(initializer.expression);
              if (!symbol || symbol.getName() !== "forwardRef")
                return;
              initializer = initializer.arguments[0];
            }
            if (initializer && (ts.isArrowFunction(initializer) || ts.isFunctionExpression(initializer)))
              return initializer;
          }
        }, Parser2.prototype.extractDefaultPropsFromComponent = function(symbol, source) {
          var _this = this, possibleStatements = __spreadArray(__spreadArray([], source.statements.filter(function(stmt) {
            return !!stmt.name;
          }).filter(function(stmt) {
            return _this.checker.getSymbolAtLocation(stmt.name) === symbol;
          })), source.statements.filter(function(stmt) {
            return ts.isExpressionStatement(stmt) || ts.isVariableStatement(stmt);
          }));
          return possibleStatements.reduce(function(res, statement) {
            if (statementIsClassDeclaration(statement) && statement.members.length) {
              var possibleDefaultProps = statement.members.filter(function(member) {
                return member.name && getPropertyName(member.name) === "defaultProps";
              });
              if (!possibleDefaultProps.length)
                return res;
              var defaultProps = possibleDefaultProps[0], initializer = defaultProps.initializer;
              if (!initializer)
                return res;
              for (var properties = initializer.properties; ts.isIdentifier(initializer); ) {
                var defaultPropsReference = _this.checker.getSymbolAtLocation(initializer);
                if (defaultPropsReference) {
                  var declarations = defaultPropsReference.getDeclarations();
                  if (declarations) {
                    if (ts.isImportSpecifier(declarations[0])) {
                      var symbol2 = _this.checker.getSymbolAtLocation(declarations[0].name);
                      if (!symbol2)
                        continue;
                      var aliasedSymbol = _this.checker.getAliasedSymbol(symbol2);
                      if (aliasedSymbol && aliasedSymbol.declarations && aliasedSymbol.declarations.length)
                        initializer = aliasedSymbol.declarations[0].initializer;
                      else
                        continue;
                    } else
                      initializer = declarations[0].initializer;
                    properties = initializer.properties;
                  }
                }
              }
              var propMap = {};
              return properties && (propMap = _this.getPropMap(properties)), __assign(__assign({}, res), propMap);
            } else if (statementIsStatelessWithDefaultProps(statement)) {
              var propMap_1 = {};
              return statement.getChildren().forEach(function(child) {
                var right = child.right;
                if (right && ts.isIdentifier(right)) {
                  var value = source.locals.get(right.escapedText);
                  value && value.valueDeclaration && ts.isVariableDeclaration(value.valueDeclaration) && value.valueDeclaration.initializer && (right = value.valueDeclaration.initializer);
                }
                if (right) {
                  var properties2 = right.properties;
                  properties2 && (propMap_1 = _this.getPropMap(properties2));
                }
              }), __assign(__assign({}, res), propMap_1);
            }
            var functionStatement = _this.getFunctionStatement(statement);
            if (functionStatement && functionStatement.parameters && functionStatement.parameters.length) {
              var name = functionStatement.parameters[0].name;
              if (ts.isObjectBindingPattern(name))
                return __assign(__assign({}, res), _this.getPropMap(name.elements));
            }
            return res;
          }, {});
        }, Parser2.prototype.getLiteralValueFromImportSpecifier = function(property) {
          if (ts.isImportSpecifier(property)) {
            var symbol = this.checker.getSymbolAtLocation(property.name);
            if (!symbol)
              return null;
            var aliasedSymbol = this.checker.getAliasedSymbol(symbol);
            return aliasedSymbol && aliasedSymbol.declarations && aliasedSymbol.declarations.length ? this.getLiteralValueFromPropertyAssignment(aliasedSymbol.declarations[0]) : null;
          }
          return null;
        }, Parser2.prototype.getLiteralValueFromPropertyAssignment = function(property) {
          var initializer = property.initializer;
          if (!initializer && ts.isShorthandPropertyAssignment(property)) {
            var symbol = this.checker.getShorthandAssignmentValueSymbol(property), decl = symbol && symbol.valueDeclaration;
            decl && decl.initializer && (initializer = decl.initializer);
          }
          if (initializer)
            switch (initializer.kind) {
              case ts.SyntaxKind.FalseKeyword:
                return this.savePropValueAsString ? "false" : !1;
              case ts.SyntaxKind.TrueKeyword:
                return this.savePropValueAsString ? "true" : !0;
              case ts.SyntaxKind.StringLiteral:
                return initializer.text.trim();
              case ts.SyntaxKind.PrefixUnaryExpression:
                return this.savePropValueAsString ? initializer.getFullText().trim() : Number(initializer.getFullText());
              case ts.SyntaxKind.NumericLiteral:
                return this.savePropValueAsString ? "" + initializer.text : Number(initializer.text);
              case ts.SyntaxKind.NullKeyword:
                return this.savePropValueAsString ? "null" : null;
              case ts.SyntaxKind.Identifier:
                if (initializer.text === "undefined")
                  return "undefined";
                var symbol = this.checker.getSymbolAtLocation(initializer);
                return symbol && symbol.declarations && symbol.declarations.length ? ts.isImportSpecifier(symbol.declarations[0]) ? this.getLiteralValueFromImportSpecifier(symbol.declarations[0]) : this.getLiteralValueFromPropertyAssignment(symbol.declarations[0]) : null;
              case ts.SyntaxKind.PropertyAccessExpression: {
                var symbol_1 = this.checker.getSymbolAtLocation(initializer);
                if (symbol_1 && symbol_1.declarations && symbol_1.declarations.length) {
                  var declaration = symbol_1.declarations[0];
                  if (ts.isBindingElement(declaration) || ts.isPropertyAssignment(declaration))
                    return this.getLiteralValueFromPropertyAssignment(declaration);
                }
              }
              case ts.SyntaxKind.ObjectLiteralExpression:
              default:
                try {
                  return initializer.getText();
                } catch {
                  return null;
                }
            }
        }, Parser2.prototype.getPropMap = function(properties) {
          var _this = this;
          return properties.reduce(function(acc, property) {
            var propertyName = getPropertyName(ts.isBindingElement(property) && property.propertyName || property.name);
            if (ts.isSpreadAssignment(property) || !propertyName)
              return acc;
            var literalValue = _this.getLiteralValueFromPropertyAssignment(property);
            return (typeof literalValue == "string" || typeof literalValue == "number" || typeof literalValue == "boolean" || literalValue === null) && (acc[propertyName] = literalValue), acc;
          }, {});
        }, Parser2;
      })()
    );
    exports.Parser = Parser;
    function statementIsClassDeclaration(statement) {
      return !!statement.members;
    }
    function statementIsStatelessWithDefaultProps(statement) {
      for (var children = statement.getChildren(), _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i], left = child.left;
        if (left) {
          var name = left.name;
          if (name && name.escapedText === "defaultProps")
            return !0;
        }
      }
      return !1;
    }
    function getPropertyName(name) {
      switch (name.kind) {
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.Identifier:
          return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
          return name.getText();
        default:
          return null;
      }
    }
    function formatTag(tag) {
      var result = "@" + tag.name;
      return tag.text && (result += " " + ts.displayPartsToString(tag.text)), result;
    }
    function getTextValueOfClassMember(classDeclaration, memberName) {
      var classDeclarationMembers = classDeclaration.members || [], textValue = (classDeclarationMembers && classDeclarationMembers.filter(function(member) {
        return ts.isPropertyDeclaration(member);
      }).filter(function(member) {
        var name = ts.getNameOfDeclaration(member);
        return name && name.text === memberName;
      }).map(function(member) {
        var property = member;
        return property.initializer && property.initializer.text;
      }))[0];
      return textValue || "";
    }
    function getTextValueOfFunctionProperty(exp, source, propertyName) {
      var identifierStatements = source.statements.filter(function(statement) {
        return ts.isExpressionStatement(statement);
      }).filter(function(statement) {
        var _a, _b, _c, _d, expr = statement.expression, locals = Array.from(source.locals), hasOneLocalExport = locals.filter(function(local) {
          return !!local[1].exports;
        }).length === 1;
        if (hasOneLocalExport)
          return expr.left && expr.left.name && expr.left.name.escapedText === propertyName;
        var flowNodeNameEscapedText = (_d = (_c = (_b = (_a = statement) === null || _a === void 0 ? void 0 : _a.flowNode) === null || _b === void 0 ? void 0 : _b.node) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.escapedText;
        return expr.left && expr.left.name && expr.left.name.escapedText === propertyName && flowNodeNameEscapedText === exp.escapedName;
      }).filter(function(statement) {
        return ts.isStringLiteral(statement.expression.right);
      }).map(function(statement) {
        var expressionStatement = statement.expression, name = expressionStatement.left.expression.escapedText, value = expressionStatement.right.text;
        return [name, value];
      });
      if (identifierStatements.length > 0) {
        var locatedStatement = identifierStatements.find(function(statement) {
          return statement[0] === exp.escapedName;
        });
        return locatedStatement ? locatedStatement[1] : identifierStatements[0][1] || "";
      }
      return "";
    }
    function computeComponentName(exp, source, customComponentTypes) {
      customComponentTypes === void 0 && (customComponentTypes = []);
      var exportName = exp.getName(), statelessDisplayName = getTextValueOfFunctionProperty(exp, source, "displayName"), statefulDisplayName = exp.valueDeclaration && ts.isClassDeclaration(exp.valueDeclaration) && getTextValueOfClassMember(exp.valueDeclaration, "displayName");
      if (statelessDisplayName || statefulDisplayName)
        return statelessDisplayName || statefulDisplayName || "";
      var defaultComponentTypes = [
        "default",
        "__function",
        "Stateless",
        "StyledComponentClass",
        "StyledComponent",
        "IStyledComponent",
        "FunctionComponent",
        "StatelessComponent",
        "ForwardRefExoticComponent",
        "MemoExoticComponent"
      ], supportedComponentTypes = __spreadArray(__spreadArray([], defaultComponentTypes), customComponentTypes);
      return supportedComponentTypes.indexOf(exportName) !== -1 ? getDefaultExportForFile(source) : exportName;
    }
    function getDefaultExportForFile(source) {
      var name = path.basename(source.fileName).split(".")[0], filename = name === "index" ? path.basename(path.dirname(source.fileName)) : name, identifier = filename.replace(/^[^A-Z]*/gi, "").replace(/[^A-Z0-9]*/gi, "");
      return identifier.length ? identifier : "DefaultName";
    }
    exports.getDefaultExportForFile = getDefaultExportForFile;
    function isTypeLiteral(node) {
      return node.kind === ts.SyntaxKind.TypeLiteral;
    }
    function getDeclarations(prop) {
      var declarations = prop.getDeclarations();
      if (!(declarations === void 0 || declarations.length === 0)) {
        for (var parents = [], _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
          var declaration = declarations_1[_i], parent = declaration.parent;
          if (!(!isTypeLiteral(parent) && !isInterfaceOrTypeAliasDeclaration(parent))) {
            var parentName = "name" in parent ? parent.name.text : "TypeLiteral", fileName = parent.getSourceFile().fileName;
            parents.push({
              fileName: trimFileName_1.trimFileName(fileName),
              name: parentName
            });
          }
        }
        return parents;
      }
    }
    function getParentType(prop) {
      var declarations = prop.getDeclarations();
      if (!(declarations == null || declarations.length === 0)) {
        var parent = declarations[0].parent;
        if (isInterfaceOrTypeAliasDeclaration(parent)) {
          var parentName = parent.name.text, fileName = parent.getSourceFile().fileName;
          return {
            fileName: trimFileName_1.trimFileName(fileName),
            name: parentName
          };
        }
      }
    }
    function isInterfaceOrTypeAliasDeclaration(node) {
      return node.kind === ts.SyntaxKind.InterfaceDeclaration || node.kind === ts.SyntaxKind.TypeAliasDeclaration;
    }
    function parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider) {
      var filePaths = Array.isArray(filePathOrPaths) ? filePathOrPaths : [filePathOrPaths], program = programProvider ? programProvider() : ts.createProgram(filePaths, compilerOptions), parser = new Parser(program, parserOpts), checker = program.getTypeChecker();
      return filePaths.map(function(filePath) {
        return program.getSourceFile(filePath);
      }).filter(function(sourceFile) {
        return typeof sourceFile < "u";
      }).reduce(function(docs, sourceFile) {
        var moduleSymbol = checker.getSymbolAtLocation(sourceFile);
        if (!moduleSymbol)
          return docs;
        var exports2 = checker.getExportsOfModule(moduleSymbol), componentDocs = [], exportsAndMembers = [];
        exports2.forEach(function(exp) {
          if (exportsAndMembers.push(exp), !!parser.isPlainObjectType(exp)) {
            var typeSymbol = parser.getTypeSymbol(exp);
            typeSymbol?.members && typeSymbol.members.forEach(function(member) {
              exportsAndMembers.push(member);
            });
          }
        }), exportsAndMembers.forEach(function(exp) {
          var doc = parser.getComponentInfo(exp, sourceFile, parserOpts.componentNameResolver, parserOpts.customComponentTypes);
          doc && componentDocs.push(doc);
          var componentExports = parser.getComponentExports(exp);
          componentExports && componentExports.exports.forEach(function(symbol) {
            if (!(symbol.flags & ts.SymbolFlags.Prototype)) {
              if (symbol.flags & ts.SymbolFlags.Method) {
                var signature = parser.getCallSignature(symbol), returnType = checker.typeToString(signature.getReturnType());
                if (returnType !== "Element")
                  return;
              }
              var doc2 = parser.getComponentInfo(symbol, sourceFile, parserOpts.componentNameResolver, parserOpts.customComponentTypes);
              if (doc2) {
                var prefix = componentExports.symbol.escapedName === "default" ? "" : componentExports.symbol.escapedName + ".";
                componentDocs.push(__assign(__assign({}, doc2), { displayName: "" + prefix + symbol.escapedName }));
              }
            }
          });
        });
        var componentDocsNoDuplicates = componentDocs.reduce(function(prevVal, comp) {
          var duplicate = prevVal.find(function(compDoc) {
            return compDoc.displayName === comp.displayName;
          });
          return duplicate ? prevVal : __spreadArray(__spreadArray([], prevVal), [comp]);
        }, []), filteredComponentDocs = componentDocsNoDuplicates.filter(function(comp, index, comps) {
          return comps.slice(index + 1).every(function(innerComp) {
            return innerComp.displayName !== comp.displayName;
          });
        });
        return __spreadArray(__spreadArray([], docs), filteredComponentDocs);
      }, []);
    }
  }
});

// ../../../node_modules/react-docgen-typescript/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/react-docgen-typescript/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Parser = exports.withCustomConfig = exports.withDefaultConfig = exports.withCompilerOptions = exports.getDefaultExportForFile = exports.parse = void 0;
    var parser_1 = require_parser();
    Object.defineProperty(exports, "getDefaultExportForFile", { enumerable: !0, get: function() {
      return parser_1.getDefaultExportForFile;
    } });
    Object.defineProperty(exports, "parse", { enumerable: !0, get: function() {
      return parser_1.parse;
    } });
    Object.defineProperty(exports, "Parser", { enumerable: !0, get: function() {
      return parser_1.Parser;
    } });
    Object.defineProperty(exports, "withCompilerOptions", { enumerable: !0, get: function() {
      return parser_1.withCompilerOptions;
    } });
    Object.defineProperty(exports, "withCustomConfig", { enumerable: !0, get: function() {
      return parser_1.withCustomConfig;
    } });
    Object.defineProperty(exports, "withDefaultConfig", { enumerable: !0, get: function() {
      return parser_1.withDefaultConfig;
    } });
  }
});
export default require_lib();
