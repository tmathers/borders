{"version":3,"sources":["../src/index.ts","../src/debug.ts","../src/logFile.ts","../src/path.ts","../src/resolver.ts","../src/mappings.ts"],"sourcesContent":["import * as fs from 'node:fs'\nimport * as vite from 'vite'\nimport { debug } from './debug'\nimport { createLogFile } from './logFile'\nimport type { NormalizedPath } from './path'\nimport * as path from './path'\nimport { createTsconfigResolvers, TsconfigResolvers } from './resolver'\nimport { PluginOptions, ViteResolve } from './types'\n\nexport type { PluginOptions }\n\nexport default (opts: PluginOptions = {}) => {\n  let tsconfigResolvers: TsconfigResolvers\n  let isFirstBuild = true\n\n  const logFile = opts.logFile\n    ? createLogFile(\n        opts.logFile === true ? 'vite-tsconfig-paths.log' : opts.logFile\n      )\n    : null\n\n  debug('Plugin options:', opts)\n\n  const plugin = {\n    name: 'vite-tsconfig-paths',\n    enforce: 'pre',\n    configResolved(config: Pick<vite.ResolvedConfig, 'logger' | 'root'>) {\n      let projectRoot: NormalizedPath\n      let workspaceRoot: NormalizedPath\n\n      if (opts.root) {\n        projectRoot = workspaceRoot = path.resolve(config.root, opts.root)\n      } else {\n        projectRoot = path.normalize(config.root)\n        workspaceRoot = path.normalize(vite.searchForWorkspaceRoot(config.root))\n      }\n\n      debug('Project root:  ', projectRoot)\n      debug('Workspace root:', workspaceRoot)\n\n      tsconfigResolvers = createTsconfigResolvers({\n        ...opts,\n        projectRoot,\n        workspaceRoot,\n        logFile,\n        logger: config.logger,\n        skip(dir: string) {\n          if (dir === '.git' || dir === 'node_modules') {\n            return true\n          }\n          if (typeof opts.skip === 'function') {\n            return opts.skip(dir)\n          }\n          return false\n        },\n      })\n\n      tsconfigResolvers.reset()\n    },\n    configureServer(server: Pick<vite.ViteDevServer, 'watcher'>) {\n      tsconfigResolvers.watch(server.watcher)\n    },\n    buildStart() {\n      if (isFirstBuild) {\n        isFirstBuild = false\n        return\n      }\n      tsconfigResolvers.reset()\n    },\n    async resolveId(\n      this: Pick<vite.Rollup.PluginContext, 'resolve'>,\n      id: string,\n      importer: string | undefined,\n      options: {}\n    ) {\n      if (!importer) {\n        logFile?.write('emptyImporter', { importer, id })\n        return\n      }\n      if (path.relativeImportRE.test(id)) {\n        logFile?.write('relativeId', { importer, id })\n        return\n      }\n      if (id.includes('\\0')) {\n        logFile?.write('virtualId', { importer, id })\n        return\n      }\n\n      // Attempt to coerce the importer to a file path. The importer may be\n      // a \"virtual module\" that may not exist in the filesystem, or it may\n      // be derived from a real file.\n      let importerFile = importer\n      if (importer[0] === '\\0') {\n        // Check if the real file path is provided in the query string. For\n        // example, the WXT framework for browser extensions does this.\n        const index = importer.indexOf('?')\n        if (index !== -1) {\n          const query = path.normalize(importer.slice(index + 1))\n          if (path.isAbsolute(query) && fs.existsSync(query)) {\n            debug('Rewriting virtual importer to real file:', importer)\n            importerFile = query\n          } else {\n            logFile?.write('virtualImporter', { importer, id })\n            return\n          }\n        } else {\n          logFile?.write('virtualImporter', { importer, id })\n          return\n        }\n      }\n\n      // For Vite 4 and under, skipSelf needs to be set.\n      const resolveOptions = { ...options, skipSelf: true }\n      const viteResolve: ViteResolve = async (id, importer) =>\n        (await this.resolve(id, importer, resolveOptions))?.id\n\n      for await (const resolveId of tsconfigResolvers.get(importerFile)) {\n        const [resolved, matched] = await resolveId(\n          viteResolve,\n          id,\n          importerFile\n        )\n        if (resolved) {\n          return resolved\n        }\n        if (matched) {\n          // Once a matching resolver is found, stop looking.\n          break\n        }\n      }\n    },\n  } as const\n\n  return plugin satisfies vite.Plugin\n}\n","import createDebug from 'debug'\n\nexport const debug = createDebug('vite-tsconfig-paths')\n\nif (process.env.TEST === 'vite-tsconfig-paths') {\n  createDebug.enable('vite-tsconfig-paths')\n}\n","import { createWriteStream, statSync, writeFileSync } from 'node:fs'\nimport { debug } from './debug'\n\ntype ImportDetails = { importer: string | undefined; id: string }\ntype ConfigDetails = ImportDetails & { configPath: string }\ntype ResolveDetails = ConfigDetails & { resolvedId: string }\ntype NotFoundDetails = ConfigDetails & { candidates: string[] | null }\n\nexport type LogEvent =\n  | ['emptyImporter', ImportDetails]\n  | ['virtualImporter', ImportDetails]\n  | ['unsupportedExtension', ImportDetails]\n  | ['relativeId', ImportDetails]\n  | ['virtualId', ImportDetails]\n  | ['resolvedWithBaseUrl', ResolveDetails]\n  | ['resolvedWithPaths', ResolveDetails]\n  | ['resolvedFromCache', ResolveDetails]\n  | ['notFound', NotFoundDetails]\n  | ['configMismatch', ConfigDetails]\n\n/**\n * This log file is dedicated to the resolution process. Other debug logs\n * will appear in the console if you set `DEBUG=vite-tsconfig-paths` in\n * your shell environment.\n */\nexport function createLogFile(logFilePath: string) {\n  let mtime: number | undefined\n  try {\n    mtime = statSync(logFilePath).mtime.getTime()\n  } catch {}\n\n  // Clear the log file if it's older than 10 seconds.\n  if (!mtime || Date.now() - mtime > 10_000) {\n    debug('Clearing log file:', logFilePath)\n    writeFileSync(logFilePath, '')\n  }\n\n  const logFile = createWriteStream(logFilePath, {\n    flags: 'a',\n    encoding: 'utf-8',\n  })\n\n  return {\n    write(...event: LogEvent) {\n      logFile.write(event[0] + ': ' + JSON.stringify(event[1]) + '\\n')\n    },\n  }\n}\n\nexport type LogFileWriter = ReturnType<typeof createLogFile>\n","import * as os from 'node:os'\nimport * as path from 'node:path'\nimport * as vite from 'vite'\n\nconst isWindows = os.platform() == 'win32'\n\nexport type NormalizedPath = string & { __normalized: true }\n\nexport const normalize = (p: string): NormalizedPath => {\n  let output = vite.normalizePath(p)\n  // Normalize the drive letter casing on Windows to upper case,\n  if (isWindows && output[1] === ':') {\n    output = output[0].toUpperCase() + output.substring(1)\n  }\n  return output as NormalizedPath\n}\n\nexport const parse: (p: NormalizedPath) => {\n  root: NormalizedPath\n} = path.parse as any\n\nexport const resolve = isWindows\n  ? (...paths: string[]) => normalize(path.win32.resolve(...paths))\n  : (path.posix.resolve as (...paths: string[]) => NormalizedPath)\n\nexport const isAbsolute = isWindows\n  ? path.win32.isAbsolute\n  : path.posix.isAbsolute\n\n/** Only call this on normalized paths */\nexport const join = path.posix.join as (\n  ...paths: NormalizedPath[]\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const relative = path.posix.relative as (\n  from: NormalizedPath,\n  to: NormalizedPath\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const basename = path.posix.basename as (\n  path: NormalizedPath,\n  suffix?: string\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const dirname = path.dirname as (p: NormalizedPath) => NormalizedPath\n\nexport const relativeImportRE = /^\\.\\.?(\\/|$)/\n","import globRex from 'globrex'\nimport * as fs from 'node:fs'\nimport { readdir } from 'node:fs/promises'\nimport { isAbsolute, join, relative } from 'node:path'\nimport { inspect } from 'node:util'\nimport * as tsconfck from 'tsconfck'\nimport * as vite from 'vite'\nimport { debug } from './debug'\nimport { LogFileWriter } from './logFile'\nimport { resolvePathMappings } from './mappings'\nimport type { NormalizedPath } from './path'\nimport * as path from './path'\nimport {\n  Directory,\n  PluginOptions,\n  Project,\n  Resolver,\n  ViteResolve,\n} from './types'\n\nconst notApplicable = [undefined, false] as const\nconst notFound = [undefined, true] as const\n\n/** A directory with no projects. */\nconst emptyDirectory: Directory = {\n  projects: Object.freeze([]) as any,\n  lazyDiscovery: false,\n}\n\ntype Logger = Pick<vite.Logger, 'error' | 'hasErrorLogged'>\n\nexport type TsconfigResolvers = ReturnType<typeof createTsconfigResolvers>\n\nexport function createTsconfigResolvers({\n  projectRoot,\n  workspaceRoot,\n  skip = () => false,\n  logFile,\n  logger,\n  ...opts\n}: Omit<PluginOptions, 'root' | 'logFile'> & {\n  projectRoot: string\n  workspaceRoot: string\n  logFile?: LogFileWriter | null\n  logger: Logger\n}) {\n  let initializing: Promise<void> | undefined\n  let directoryCache: Map<string, Directory>\n  let resolversByProject: WeakMap<Project, Resolver>\n  let isFirstParseError = true\n  let hasTypeScriptDep = false\n\n  if (opts.parseNative) {\n    try {\n      const pkgJson = fs.readFileSync(\n        join(workspaceRoot, 'package.json'),\n        'utf8'\n      )\n      const pkg = JSON.parse(pkgJson)\n      const deps = { ...pkg.dependencies, ...pkg.devDependencies }\n      hasTypeScriptDep = 'typescript' in deps\n    } catch (e: any) {\n      if (e.code != 'ENOENT') {\n        throw e\n      }\n    }\n  }\n\n  const configNames = opts.configNames || ['tsconfig.json', 'jsconfig.json']\n  debug(\n    'Only tsconfig files with a name in this list are discoverable:',\n    configNames\n  )\n\n  const parseProject = async (\n    tsconfigFile: string\n  ): Promise<Project | null> => {\n    tsconfigFile = path.normalize(tsconfigFile)\n\n    try {\n      return (\n        hasTypeScriptDep\n          ? await tsconfck.parseNative(tsconfigFile)\n          : await tsconfck.parse(tsconfigFile)\n      ) as Project\n    } catch (error: any) {\n      if (opts.ignoreConfigErrors) {\n        debug('[!] Failed to parse tsconfig file at %s', tsconfigFile)\n        if (isFirstParseError) {\n          debug('Remove the `ignoreConfigErrors` option to see the error.')\n        }\n      } else {\n        logger.error(\n          '[tsconfig-paths] An error occurred while parsing \"' +\n            tsconfigFile +\n            '\". See below for details.' +\n            (isFirstParseError\n              ? ' To disable this message, set the `ignoreConfigErrors` option to true.'\n              : ''),\n          { error }\n        )\n        if (!logger.hasErrorLogged(error)) {\n          console.error(error)\n        }\n      }\n      isFirstParseError = false\n      return null\n    }\n  }\n\n  // File watcher hooks\n  let onBeforeAddProject: ((project: Project) => void) | undefined\n  let onParseError: ((tsconfigFile: string) => void) | undefined\n\n  const addProject = (project: Project, data?: Directory) => {\n    const tsconfigFile = project.tsconfigFile\n    const dir = path.normalize(path.dirname(tsconfigFile))\n    data ??= directoryCache.get(dir)\n\n    // Sanity check\n    if (data?.projects.some((p) => p.tsconfigFile === tsconfigFile)) {\n      return\n    }\n\n    onBeforeAddProject?.(project)\n\n    // Referenced projects must be added first, so they can override\n    // the parent project's paths if both are in the same directory.\n    if (project.referenced) {\n      project.referenced.forEach((projectRef) => {\n        addProject(projectRef)\n      })\n      // Ensure the latest directory data is used. One of the project\n      // references may have updated it.\n      data = directoryCache.get(dir)\n    }\n\n    const resolver = createResolver(project, opts, logFile)\n    if (resolver) {\n      resolversByProject.set(project, resolver)\n    }\n\n    if (!data || data === emptyDirectory) {\n      directoryCache.set(\n        dir,\n        (data = {\n          projects: [],\n          lazyDiscovery: null,\n        })\n      )\n    }\n\n    data.projects.push(project)\n  }\n\n  const loadProject = async (tsconfigFile: string, data?: Directory) => {\n    const project = await parseProject(tsconfigFile)\n    if (project) {\n      addProject(project, data)\n    } else {\n      onParseError?.(tsconfigFile)\n    }\n  }\n\n  // Ensure a deterministic order.\n  const sortProjects = (projects: Project[]) => {\n    projects.sort((left, right) =>\n      left.tsconfigFile.localeCompare(right.tsconfigFile)\n    )\n  }\n\n  const processConfigFile = async (\n    dir: NormalizedPath,\n    name: string,\n    data = directoryCache.get(dir)\n  ): Promise<void> => {\n    if (!data) {\n      return // Wait to be loaded on-demand.\n    }\n    const file = path.join(dir, name as NormalizedPath)\n    if (data.projects.some((p) => p.tsconfigFile === file)) {\n      return\n    }\n    await loadProject(file, data)\n  }\n\n  const loadEagerProjects = async () => {\n    let projectPaths: string[]\n    if (opts.projects) {\n      projectPaths = opts.projects.map((file) => {\n        if (!file.endsWith('.json')) {\n          file = join(file, 'tsconfig.json')\n        }\n        return path.resolve(projectRoot, file)\n      })\n    } else {\n      if (opts.projectDiscovery === 'lazy') {\n        return\n      }\n      projectPaths = await tsconfck.findAll(workspaceRoot, {\n        configNames,\n        skip,\n      })\n    }\n\n    debug('Eagerly parsing these projects:', projectPaths)\n\n    await Promise.all(Array.from(new Set(projectPaths), (p) => loadProject(p)))\n    for (const data of directoryCache.values()) {\n      sortProjects(data.projects)\n    }\n  }\n\n  const resetResolvers = () => {\n    directoryCache = new Map()\n    resolversByProject = new WeakMap()\n    initializing = loadEagerProjects()\n  }\n\n  // Only used when projectDiscovery is 'lazy'.\n  const discoverProjects = async (dir: NormalizedPath, data: Directory) => {\n    debug('Searching directory for tsconfig files:', dir)\n    const names = await readdir(dir).catch(() => [])\n\n    await Promise.all(\n      names\n        .filter((name) => configNames.includes(name))\n        .map((name) => {\n          return processConfigFile(dir, name, data)\n        })\n    )\n\n    if (data.projects.length) {\n      sortProjects(data.projects)\n      if (debug.enabled) {\n        debug(\n          `Directory \"${dir}\" contains the following tsconfig files:`,\n          data.projects.map((p) => path.basename(p.tsconfigFile))\n        )\n      }\n    } else {\n      // No projects found. Reduce memory usage with a stand-in.\n      directoryCache.set(dir, emptyDirectory)\n      debug('No tsconfig files found in directory:', dir)\n    }\n  }\n\n  const getResolvers = async function* (\n    importer: string\n  ): AsyncIterable<Resolver> {\n    await initializing\n\n    let dir = path.normalize(importer)\n    const { root } = path.parse(dir)\n    while (dir !== (dir = path.dirname(dir)) && dir !== root) {\n      let data = directoryCache.get(dir)\n\n      if (opts.projectDiscovery === 'lazy') {\n        if (!data) {\n          if (skip(path.basename(dir))) {\n            directoryCache.set(dir, emptyDirectory)\n            continue\n          }\n          directoryCache.set(\n            dir,\n            (data = {\n              projects: [],\n              lazyDiscovery: null,\n            })\n          )\n        }\n        await (data.lazyDiscovery ??= discoverProjects(dir, data))\n      } else if (!data) {\n        continue\n      }\n\n      for (const project of data.projects) {\n        const resolver = resolversByProject.get(project)\n        if (resolver) {\n          yield resolver\n        }\n      }\n    }\n  }\n\n  const watchProjects = (watcher: vite.FSWatcher) => {\n    onBeforeAddProject = (project) => {\n      watcher.add(project.tsconfigFile)\n      project.extended?.forEach((parent) => {\n        watcher.add(parent.tsconfigFile)\n      })\n    }\n    onParseError = (tsconfigFile) => {\n      // Try again if the file changes.\n      watcher.add(tsconfigFile)\n    }\n    watcher.on('all', (event, file) => {\n      const normalizedFile = path.normalize(file)\n      if (\n        !normalizedFile.endsWith('.json') ||\n        !path.isAbsolute(normalizedFile)\n      ) {\n        return\n      }\n      if (event === 'add') {\n        if (configNames.includes(path.basename(normalizedFile))) {\n          processConfigFile(\n            path.dirname(normalizedFile),\n            path.basename(normalizedFile)\n          ).catch(console.error)\n        }\n      } else if (event === 'change' || event === 'unlink') {\n        invalidateConfigFile(\n          path.dirname(normalizedFile),\n          path.basename(normalizedFile),\n          event\n        )\n      }\n    })\n\n    function invalidateConfigFile(\n      dir: NormalizedPath,\n      name: string,\n      event: 'change' | 'unlink'\n    ): void {\n      const data = directoryCache.get(dir)\n      if (!data) {\n        return\n      }\n      const file = path.join(dir, name as NormalizedPath)\n      const index = data.projects.findIndex(\n        (project) => project.tsconfigFile === file\n      )\n      if (index !== -1) {\n        const project = data.projects[index]\n        debug(\n          `Unloading project because of ${event} event:`,\n          project.tsconfigFile\n        )\n\n        resolversByProject.delete(project)\n        data.projects.splice(index, 1)\n\n        if (event === 'change') {\n          if (opts.projectDiscovery === 'lazy') {\n            data.lazyDiscovery = null\n          } else {\n            loadProject(project.tsconfigFile, data)\n              .then(() => {\n                sortProjects(data.projects)\n              })\n              .catch(console.error)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    reset: resetResolvers,\n    get: getResolvers,\n    watch: watchProjects,\n  }\n}\n\nfunction createResolver(\n  project: Project,\n  opts: { loose?: boolean },\n  logFile?: LogFileWriter | null\n): Resolver | null {\n  const configPath = project.tsconfigFile\n  const config = project.tsconfig\n\n  debug('Config loaded:', inspect({ configPath, config }, false, 10, true))\n\n  // Sometimes a tsconfig is not meant to be used for path resolution,\n  // but rather for pointing to other tsconfig files and possibly being\n  // extended by them. This is represented by an explicitly empty \"files\"\n  // array and a missing/empty \"include\" array.\n  if (config.files?.length == 0 && !config.include?.length) {\n    debug(\n      `[!] Skipping \"${configPath}\" as no files can be matched since \"files\" is empty and \"include\" is missing or empty.`\n    )\n    return null\n  }\n\n  const compilerOptions = config.compilerOptions || {}\n  const { baseUrl, paths } = compilerOptions\n\n  type InternalResolver = (\n    viteResolve: ViteResolve,\n    id: string,\n    importer: string\n  ) => Promise<string | undefined>\n\n  const resolveWithBaseUrl: InternalResolver | undefined = baseUrl\n    ? async (viteResolve, id, importer) => {\n        if (id[0] === '/') {\n          return\n        }\n        const absoluteId = join(baseUrl, id)\n        const resolvedId = await viteResolve(absoluteId, importer)\n        if (resolvedId) {\n          logFile?.write('resolvedWithBaseUrl', {\n            importer,\n            id,\n            resolvedId,\n            configPath,\n          })\n          return resolvedId\n        }\n      }\n    : undefined\n\n  let resolveId: InternalResolver\n  if (paths) {\n    const pathsRootDir = resolvePathsRootDir(project)\n    const pathMappings = resolvePathMappings(paths, pathsRootDir)\n\n    const resolveWithPaths: InternalResolver = async (\n      viteResolve,\n      id,\n      importer\n    ) => {\n      const candidates = logFile ? ([] as string[]) : null\n      for (const mapping of pathMappings) {\n        const match = id.match(mapping.pattern)\n        if (!match) {\n          continue\n        }\n        for (let pathTemplate of mapping.paths) {\n          let starCount = 0\n          const mappedId = pathTemplate.replace(/\\*/g, () => {\n            // There may exist more globs in the path template than in\n            // the match pattern. In that case, we reuse the final glob\n            // match.\n            const matchIndex = Math.min(++starCount, match.length - 1)\n            return match[matchIndex]\n          })\n          candidates?.push(mappedId)\n          const resolvedId = await viteResolve(mappedId, importer)\n          if (resolvedId) {\n            logFile?.write('resolvedWithPaths', {\n              importer,\n              id,\n              resolvedId,\n              configPath,\n            })\n            return resolvedId\n          }\n        }\n      }\n      logFile?.write('notFound', {\n        importer,\n        id,\n        candidates,\n        configPath,\n      })\n    }\n\n    if (resolveWithBaseUrl) {\n      resolveId = async (viteResolve, id, importer) =>\n        (await resolveWithPaths(viteResolve, id, importer)) ??\n        (await resolveWithBaseUrl(viteResolve, id, importer))\n    } else {\n      resolveId = resolveWithPaths\n    }\n  } else if (resolveWithBaseUrl) {\n    resolveId = resolveWithBaseUrl\n  } else {\n    debug(`[!] Skipping \"${configPath}\" as no paths or baseUrl are defined.`)\n    return null\n  }\n\n  const configDir = path.normalize(path.dirname(configPath))\n\n  let outDir = compilerOptions.outDir && path.normalize(compilerOptions.outDir)\n\n  // When `tsconfck.parseNative` is used, the outDir is absolute, which\n  // is not what `getIncluder` expects.\n  if (outDir && path.isAbsolute(outDir)) {\n    outDir = path.relative(configDir, outDir)\n  }\n\n  const isIncludedRelative = getIncluder(\n    config.include?.map((p) => ensureRelative(configDir, p)),\n    config.exclude?.map((p) => ensureRelative(configDir, p)),\n    outDir\n  )\n\n  const importerExtRE = opts.loose\n    ? /$/\n    : compilerOptions.allowJs ||\n      path.basename(configPath).startsWith('jsconfig.')\n    ? /\\.(astro|mdx|svelte|vue|[mc]?[jt]sx?)$/\n    : /\\.[mc]?tsx?$/\n\n  const resolutionCache = new Map<string, string>()\n\n  return async (viteResolve, id, importer) => {\n    // Remove query and hash parameters from the importer path.\n    const importerFile = path.normalize(importer.replace(/[#?].+$/, ''))\n\n    // Ignore importers with unsupported extensions.\n    if (!importerExtRE.test(importerFile)) {\n      logFile?.write('unsupportedExtension', { importer, id })\n      return notApplicable\n    }\n\n    // Respect the include/exclude properties.\n    const relativeImporterFile = path.relative(configDir, importerFile)\n    if (!isIncludedRelative(relativeImporterFile)) {\n      logFile?.write('configMismatch', { importer, id, configPath })\n      return notApplicable\n    }\n\n    // Find and remove Vite's suffix (e.g. \"?url\") if present.\n    // If the path is resolved, the suffix will be added back.\n    const suffix = /\\?.+$/.exec(id)?.[0]\n    if (suffix) {\n      id = id.slice(0, -suffix.length)\n    }\n\n    let resolvedId = resolutionCache.get(id)\n    if (resolvedId) {\n      logFile?.write('resolvedFromCache', {\n        importer,\n        id,\n        resolvedId,\n        configPath,\n      })\n    } else {\n      resolvedId = await resolveId(viteResolve, id, importer)\n      if (!resolvedId) {\n        return notFound\n      }\n      resolutionCache.set(id, resolvedId)\n    }\n\n    // Restore the suffix if one was removed earlier.\n    if (suffix) {\n      resolvedId += suffix\n    }\n\n    return [resolvedId, true]\n  }\n}\n\nfunction resolvePathsRootDir(project: Project): string {\n  if (project.result) {\n    const { options } = project.result\n    if (options && typeof options.pathsBasePath === 'string') {\n      return options.pathsBasePath\n    }\n    return path.dirname(project.tsconfigFile)\n  }\n  const baseUrl = project.tsconfig.compilerOptions?.baseUrl\n  if (baseUrl) {\n    return baseUrl\n  }\n  const projectWithPaths = project.extended?.find(\n    (project) => project.tsconfig.compilerOptions?.paths\n  )\n  return path.dirname((projectWithPaths ?? project).tsconfigFile)\n}\n\nconst defaultInclude = ['**/*']\nconst defaultExclude = [\n  '**/node_modules',\n  '**/bower_components',\n  '**/jspm_packages',\n]\n\n/**\n * The returned function does not support absolute paths.\n * Be sure to call `path.relative` on your path first.\n */\nfunction getIncluder(\n  includePaths = defaultInclude,\n  excludePaths = defaultExclude,\n  outDir?: string\n) {\n  if (outDir) {\n    excludePaths = excludePaths.concat(outDir)\n  }\n  if (includePaths.length || excludePaths.length) {\n    const includers: RegExp[] = []\n    const excluders: RegExp[] = []\n\n    includePaths.forEach(addCompiledGlob, includers)\n    excludePaths.forEach(addCompiledGlob, excluders)\n\n    if (debug.enabled) {\n      debug(`Compiled tsconfig globs:`, {\n        include: {\n          globs: includePaths,\n          regexes: includers,\n        },\n        exclude: {\n          globs: excludePaths,\n          regexes: excluders,\n        },\n      })\n    }\n\n    return (id: string) => {\n      id = id.replace(/\\?.+$/, '')\n      if (!path.relativeImportRE.test(id)) {\n        id = './' + id\n      }\n      const test = (glob: RegExp) => glob.test(id)\n      return includers.some(test) && !excluders.some(test)\n    }\n  }\n  return () => true\n}\n\nfunction addCompiledGlob(this: RegExp[], glob: string) {\n  const endsWithGlob = glob.split('/').pop()!.includes('*')\n  const relativeGlob = path.relativeImportRE.test(glob) ? glob : './' + glob\n  if (endsWithGlob) {\n    this.push(compileGlob(relativeGlob))\n  } else {\n    // Append a globstar to possible directories.\n    this.push(compileGlob(relativeGlob + '/**'))\n\n    // Try to match specific files (must have file extension).\n    if (/\\.\\w+$/.test(glob)) {\n      this.push(compileGlob(relativeGlob))\n    }\n  }\n}\n\nfunction compileGlob(glob: string) {\n  return globRex(glob, {\n    extended: true,\n    globstar: true,\n  }).regex\n}\n\nfunction ensureRelative(dir: string, path: string) {\n  return isAbsolute(path) ? relative(dir, path) : path\n}\n","import { resolve } from 'node:path'\n\nexport type PathMapping = {\n  pattern: RegExp\n  paths: string[]\n}\n\nexport function resolvePathMappings(\n  paths: Record<string, string[]>,\n  base: string\n) {\n  // If a module name can be matched with multiple patterns then pattern\n  // with the longest prefix will be picked.\n  const sortedPatterns = Object.keys(paths).sort(\n    (a: string, b: string) => getPrefixLength(b) - getPrefixLength(a)\n  )\n  const resolved: PathMapping[] = []\n  for (let pattern of sortedPatterns) {\n    const relativePaths = paths[pattern]\n    pattern = escapeStringRegexp(pattern).replace(/\\*/g, '(.+)')\n    resolved.push({\n      pattern: new RegExp('^' + pattern + '$'),\n      paths: relativePaths.map((relativePath) => resolve(base, relativePath)),\n    })\n  }\n  return resolved\n}\n\nfunction getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf('*')\n  return pattern.substr(0, prefixLength).length\n}\n\n// Adapted from:\n// https://github.com/sindresorhus/escape-string-regexp/blob/ba9a4473850cb367936417e97f1f2191b7cc67dd/index.js\n//\n// MIT License\n//\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://\n// sindresorhus.com)\n//\nfunction escapeStringRegexp(string: string) {\n  // Escape characters with special meaning either inside or outside\n  // character sets. Use a simple backslash escape when it’s always\n  // valid, and a `\\xnn` escape when the simpler form would be\n  // disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n}\n"],"mappings":"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","names":["fs","vite","parse","dirname","isAbsolute","join","relative","resolve","join","dirname","parse","_a","project","path","isAbsolute","relative","id","importer"]}